package flogger

type errorType struct {
	Code    uint   `json:"code,omitempty"` // Данное поле необязательно для уменьшения объема логгируемых данных
	Type    string `json:"type,omitempty"` // Данное поле необязательно для уменьшения объема логгируемых данных
	Message string `json:"message"`
}

/*	Вопрос: Почему для полиморфизма обработки ошибки вместо интерфейса использованы указатели на функции?
**	Ответ: Интерфейс используется для полиморфизма объекта. Использование объекта имеет смысл в случае если объект имеет состояние.
**		Использование в качестве объекта самой ошибки неудобно так как перед передачей ошибки в данный модуль ее
**		нужно "приготовить" (кастить), а это значит придется вводить зависимость данного модуля от модуля ошибок. А создание
**		дополнительного объекта не имеет смысла так как объект извлекающий код, тип и сообщение ошибки
**		не имеет состояния.
**		Если передавать логгеру уже распарсенную ошибку есть риск допустить ошибку так как скорее всего
**		это будет нецентрализовано. А значит в лучшем случае придется либо делать повторное использование кода от
**		сервиса к сервису, либо выносить обработку в сам пакет ошибок либо в пакет логгера, проблемы данного решения
**		уже описаны выше.
**	Я считаю данную реализацию лучшим решением.   Денис  */
func defaultErrorHandler(err error) (code uint, errType string, errMessage string) {
	return 0, "", err.Error()
}
